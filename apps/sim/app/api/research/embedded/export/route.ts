import { NextRequest, NextResponse } from 'next/server'
import { createLogger } from '@/lib/logs/console-logger'
import { getSession } from '@/lib/auth'

const logger = createLogger('api/research/embedded/export')

interface ExportRequest {
  format: 'pdf' | 'docx' | 'markdown' | 'html'
  title: string
  content: string
  sources?: Array<{ title: string; url: string }>
  metadata?: any
  filename?: string
}

export async function POST(request: NextRequest) {
  try {
    const session = await getSession()
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body: ExportRequest = await request.json()
    
    // Validate required fields
    if (!body.format || !body.title || !body.content) {
      return NextResponse.json(
        { error: 'Missing required fields: format, title, or content' },
        { status: 400 }
      )
    }

    const { format, title, content, sources = [], metadata = {} } = body
    const timestamp = new Date().toISOString().split('T')[0] // YYYY-MM-DD
    const sanitizedTitle = title.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '-')
    
    logger.info('Exporting research report', { 
      format, 
      title: sanitizedTitle, 
      userId: session.user.id 
    })

    switch (format) {
      case 'markdown': {
        const markdownContent = generateMarkdownContent(title, content, sources, metadata)
        const filename = body.filename || `${sanitizedTitle}-${timestamp}.md`
        
        return new NextResponse(markdownContent, {
          headers: {
            'Content-Type': 'text/markdown',
            'Content-Disposition': `attachment; filename="${filename}"`,
          },
        })
      }

      case 'html': {
        const htmlContent = generateHtmlContent(title, content, sources, metadata)
        const filename = body.filename || `${sanitizedTitle}-${timestamp}.html`
        
        return new NextResponse(htmlContent, {
          headers: {
            'Content-Type': 'text/html',
            'Content-Disposition': `attachment; filename="${filename}"`,
          },
        })
      }

      case 'pdf': {
        // For now, return HTML that can be converted to PDF client-side
        // In a production environment, you might want to use a library like puppeteer
        const htmlContent = generatePdfHtmlContent(title, content, sources, metadata)
        const filename = body.filename || `${sanitizedTitle}-${timestamp}.html`
        
        return new NextResponse(htmlContent, {
          headers: {
            'Content-Type': 'text/html',
            'Content-Disposition': `attachment; filename="${filename}"`,
          },
        })
      }

      case 'docx': {
        // For now, return structured content that can be copied to Word
        // In production, you might want to use a library like docx
        const docContent = generateDocContent(title, content, sources, metadata)
        const filename = body.filename || `${sanitizedTitle}-${timestamp}.txt`
        
        return new NextResponse(docContent, {
          headers: {
            'Content-Type': 'text/plain',
            'Content-Disposition': `attachment; filename="${filename}"`,
          },
        })
      }

      default:
        return NextResponse.json(
          { error: `Unsupported export format: ${format}` },
          { status: 400 }
        )
    }

  } catch (error) {
    logger.error('Error exporting research report:', error)
    return NextResponse.json(
      { error: 'Failed to export research report' },
      { status: 500 }
    )
  }
}

function generateMarkdownContent(
  title: string, 
  content: string, 
  sources: Array<{ title: string; url: string }>, 
  metadata: any
): string {
  const timestamp = new Date().toISOString()
  
  let markdown = `# ${title}\n\n`
  markdown += `*Generated on: ${new Date(timestamp).toLocaleString()}*\n\n`
  
  if (metadata.question) {
    markdown += `## Research Question\n\n${metadata.question}\n\n`
  }
  
  markdown += `## Research Report\n\n${content}\n\n`
  
  if (sources.length > 0) {
    markdown += `## Sources\n\n`
    sources.forEach((source, index) => {
      markdown += `${index + 1}. [${source.title || source.url}](${source.url})\n`
    })
    markdown += `\n`
  }
  
  markdown += `---\n\n*Generated by TEL Cognitive Platform - Deep Research*`
  
  return markdown
}

function generateHtmlContent(
  title: string, 
  content: string, 
  sources: Array<{ title: string; url: string }>, 
  metadata: any
): string {
  const timestamp = new Date().toISOString()
  
  let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }
        h1 { color: #2563eb; border-bottom: 2px solid #e5e7eb; padding-bottom: 10px; }
        h2 { color: #374151; margin-top: 30px; }
        .metadata { background: #f9fafb; padding: 15px; border-radius: 8px; margin: 20px 0; }
        .sources { background: #fefefe; border-left: 4px solid #2563eb; padding: 15px; margin: 20px 0; }
        .sources a { color: #2563eb; text-decoration: none; }
        .sources a:hover { text-decoration: underline; }
        .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; font-size: 0.9em; color: #6b7280; }
    </style>
</head>
<body>
    <h1>${title}</h1>
    <div class="metadata">
        <em>Generated on: ${new Date(timestamp).toLocaleString()}</em>
    </div>`
  
  if (metadata.question) {
    html += `<h2>Research Question</h2><p>${metadata.question}</p>`
  }
  
  html += `<h2>Research Report</h2><div>${content}</div>`
  
  if (sources.length > 0) {
    html += `<div class="sources"><h2>Sources</h2><ol>`
    sources.forEach((source) => {
      html += `<li><a href="${source.url}" target="_blank">${source.title || source.url}</a></li>`
    })
    html += `</ol></div>`
  }
  
  html += `<div class="footer"><em>Generated by TEL Cognitive Platform - Deep Research</em></div></body></html>`
  
  return html
}

function generatePdfHtmlContent(
  title: string, 
  content: string, 
  sources: Array<{ title: string; url: string }>, 
  metadata: any
): string {
  // Generate PDF-optimized HTML
  return generateHtmlContent(title, content, sources, metadata).replace(
    '<style>',
    '<style>@media print { body { margin: 0; } } '
  )
}

function generateDocContent(
  title: string, 
  content: string, 
  sources: Array<{ title: string; url: string }>, 
  metadata: any
): string {
  const timestamp = new Date().toISOString()
  
  let docContent = `${title}\n`
  docContent += `${'='.repeat(title.length)}\n\n`
  docContent += `Generated on: ${new Date(timestamp).toLocaleString()}\n\n`
  
  if (metadata.question) {
    docContent += `Research Question\n----------------\n\n${metadata.question}\n\n`
  }
  
  docContent += `Research Report\n---------------\n\n${content}\n\n`
  
  if (sources.length > 0) {
    docContent += `Sources\n-------\n\n`
    sources.forEach((source, index) => {
      docContent += `${index + 1}. ${source.title || source.url}\n   ${source.url}\n\n`
    })
  }
  
  docContent += `\n---\nGenerated by TEL Cognitive Platform - Deep Research`
  
  return docContent
}